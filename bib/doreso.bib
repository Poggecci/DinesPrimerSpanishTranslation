

@Misc{jarke98,
  editor = 	 "M. Jarke and R. Kurki--Suonio",
  title = 	 "{Special Issue on Scenario Management}",
  howpublished = "IEEE Trans.\ on Software Engineering",
  year = 	 "1998",
  month = 	 "December",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@Article{nus98,
  author = 	 "A. Hunter and B. Nuseibeh",
  title = 	 "{Managing Inconsistent Specifications: Reasoning,
                  Analysis and Action}",
  journal = 	 "ACM Transactions on Software Engineering and
                  Methodology", 
  year = 	 "1998",
  volume = 	 "7",
  number = 	 "4",
  month = 	 "October",
  pages = 	 "335--367",
  OPTnote = 	 "",
  OPTannote = 	 ""
}



@Article{nus94,
  author = 	 "B. Nuseibeh and J. Kramer and A. Finkelstein",
  title = 	 "{A Framework for Expressing the Relationships
                  between Multiple Views in Requirements Specifications}",
  journal = 	 "IEEE Transactions on Software Engineering", 
  year = 	 "1994",
  volume = 	 "20",
  number = 	 "10",
  month = 	 "October",
  pages = 	 "760--773",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@Article{myl99,
  author = 	 "John Mylopoulos and L. Chung and E. Yu",
  title = 	 "{From Object--Oriented to Goal--Oriented
                  Requirements Analysis}",
  journal = 	 "CACM: Communications of the ACM",
  year = 	 "1999",
  volume = 	 "42",
  number = 	 "1",
  month = 	 "January",
  pages = 	 "31--37",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@Article{myl98b,
  author = 	 "John Mylopoulos",
  title = 	 "{Information Modelling in the Time of revolution}",
  journal = 	 "Information Systems",
  year = 	 "1998",
  OPTkey = 	 "",
  volume = 	 "23",
  number = 	 "3/4",
  OPTmonth = 	 "",
  pages = 	 "127--155",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@InProceedings{myl94,
  author = 	 "E. Yu and John Mylopoulos",
  title = 	 "{Understanding "why" in Software Process Modelling,
                  Analysis and Design}", 
  booktitle = 	 "{Proc.\ 16th ICSE: Intl.\ Conf.\ on Software
                  Engineering}", 
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  address = 	 "Sorrento, Italy",
  year = 	 "1994",
  publisher = "IEEE Press",
  OPTmonth = 	 "",
  OPTpages = 	 "",
  OPTnote = 	 ""}

@Article{myl92,
  author = 	 "John Mylopoulos and L. Chung and B. Nixon",
  title = 	 "{Representing and Using Non--Functional
                  Requirements: A Process--oriented Approach}",
  journal = 	 "IEEE Trans.\ on Software Engineering",
  year = 	 "1992",
  OPTkey = 	 "",
  volume = 	 "18",
  number = 	 "6",
  month = 	 "June",
  pages = 	 "483--497",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@Article{myl86,
  author = 	 "S. J. Greenspan and John Mylopoulos and A. Borgida",
  title = 	 "{A Requirements Modelling Language}",
  journal = 	 "Information Systems",
  year = 	 "1986",
  OPTkey = 	 "",
  volume = 	 "11",
  number = 	 "1",
  OPTmonth = 	 "",
  pages = 	 "9--23",
  note = 	 "(About RML)",
  OPTannote = 	 ""
}


@InProceedings{myl82,
  author = 	 "S. J. Greenspan and John Mylopoulos and A. Borgida",
  title = 	 "{Capturing More World\---Knowledge in Requirements
                  Specification}", 
  booktitle = 	 "{Proc.\ 6th ICSE: Intl.\ Conf.\ on Software
                  Engineering}", 
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  address = 	 "Tokyo, Japan",
  year = 	 "1982",
  publisher = "IEEE Computer Society Press",
  OPTmonth = 	 "",
  OPTpages = 	 "",
  OPTnote = 	 ""}


@Book{GoguenJirotka94,
  editor = 	 "Joseph A. Goguen and M. Girotka",
  title = 	 "{Requirements Engineering: Social and Technical Issues}",
  publisher = 	 "Academic Press",
  year = 	 "1994",
  OPTmonth = 	 "",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@InProceedings{GoguenLinde93,
  author = 	 "Joseph A. Goguen and C. Linde",
  title = 	 "{Techniques for Requirements Elicitation}",
  booktitle = 	 "{Proc.\ RE'93, First IEEE Symposium on Requirements
                  Engineering}", 
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  address = "San Diego, Calif., USA",
  OPTseries = 	 "",
  year = 	 "1993",
  publisher = "IEEE Computer Society Press",
  OPTmonth = 	 "",
  pages = 	 "152--164",
  OPTnote = 	 ""}



@Article{axel98c,
  author = 	 "Axel {van Lamsweerde} and L. Willemet",
  title = 	 "{Inferring Declarative Requirements
                  Specification from Operational Scenarios}",
  journal = 	 "IEEE Transaction on Software Engineering",
  year = 	 "1998",
  OPTkey = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTmonth = 	 "",
  pages = 	 "1089--1114",
  note = 	 "Special Issue on Scenario Management"}

@Article{axel00a,
  author = 	 "Axel {van Lamsweerde} and L. Willemet",
  title = 	 "{Handling Obstacles in Goal\---Driven Requirements
                  Engineering}",
  journal = 	 "IEEE Transaction on Software Engineering",
  year = 	 "2000",
  OPTkey = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTmonth = 	 "",
  OPTpages = 	 "",
  note = 	 "Special Issue on Exception Handling"}


@Article{axel98b,
  author = 	 "Axel {van Lamsweerde} and R. Darimont and E. Letier",
  title = 	 "{Managing Conflicts in Goal\---Driven Requirements
                  Engineering}", 
  journal = 	 "IEEE Transaction on Software Engineering",
  year = 	 "1998",
  OPTkey = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTmonth = 	 "",
  OPTpages = 	 "",
  note = 	 "Special Issue on Inconsistency Management in
                  Software Development"}


@InProceedings{axel98d,
  author = 	 "M. Feather and S. Fikas and Axel {van Lamsweerde} and
                  C. Ponsard",
  title = 	 "{Reconciling System
                  Requirements and Runtime Behaviours}",
  booktitle = 	 "{Proc.\ IWSSD'98, 9th Intl.\ Workshop on Software
                  Specification and Design}",
  address  =     "Isobe, Japan",
  year = 	 "1998",
  publisher = "IEEE Computer Society Press",
  month = 	 "April",
  OPTpages = 	 "",
  OPTnote = 	 ""}


@InProceedings{axel98a,
  author = 	 "Axel  {van Lamsweerde} and E. Letier",
  title = 	 "{Integrating Obstacles in Goal\---Driven
                  Requirements Engineering}",
  booktitle = 	 "{Proc.\ ICSE--98: 20th International Conference on
                  Software Enginereering}",
  OPTvolume = 	 "",
  address = "Kyoto, Japan",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "1998",
  publisher = "IEEE Computer Society Press",
  month = 	 "April",
  OPTpages = 	 "",
  OPTnote = 	 ""}



@Article{Zave97,
  author = 	 "Pamela Zave",
  title = 	 "{Classification of Research Efforts in Requirements
                  Engineering}", 
  journal = 	 "ACM Computing Surveys",
  year = 	 "1997",
  OPTkey = 	 "",
  volume = 	 "29",
  number = 	 "4",
  OPTmonth = 	 "",
  pages = 	 "315--321",
  OPTnote = 	 "",
  OPTannote = 	 ""
}



@InProceedings{axel96a,
  author = 	 "R. Darimont and Axel {van Lamsweerde}",
  title = 	 "{Formal Refinement Patterns for Goal\---Driven
                  Requirements Elaboration}",
  booktitle = 	 "{Proc.\ FSE'4, Fourth ACM SIGSOFT Symp.\ on the
                  Foundations of Software Enginering}",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "1996",
  publisher = "ACM",
  month = 	 "October",
  pages = 	 "179--190",
  OPTnote = 	 ""}


@InProceedings{axel91a,
  author = 	 "A. Dardenne and S. Fikas and Axel {van Lamsweerde}",
  title = 	 "{Goal\---Directed Concept Acquisition in
                  Requirements Elicitation}",
  booktitle = 	 "{Proc.\ IWSSD\---6, 6th Intl.\ Workshop on Software
                  Specification and Design}",
  OPTvolume = 	 "",
  address  =     "Como, Italy",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "1991",
  publisher = "IEEE Computer Society Press",
  OPTmonth = 	 "",
  pages = 	 "14--21",
  OPTnote = 	 ""}


 

@Article{axel93a,
  author = 	 "A. Dardenne and Axel  {van Lamsweerde} and S. Fikas",
  title = 	 "{Goal\---Directed Requirements Acquisition}",
  journal = 	 "Science of Computer Programming",
  year = 	 "1993",
  OPTkey = 	 "",
  volume = 	 "20",
  OPTnumber = 	 "",
  OPTmonth = 	 "",
  pages = 	 "3--50",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@InProceedings{axel00,
  author = 	 "Axel  {van Lamsweerde}",
  title = 	 "{Requirements Engineering in the Year 00: A Research
                  Perspective}",
  booktitle = 	 "{Proceedings 22nd International Conference on
                  Software Engineering}",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  series = 	 "ICSE'2000",
  year = 	 "2000",
  OPTorganization = "IEEE Computer Society",
  publisher = "IEEE Computer Society Press",
  OPTaddress = 	 "",
  OPTmonth = 	 "",
  OPTpages = 	 "",
  OPTnote = 	 ""}

@InProceedings{axel01a,
  author = 	 "Axel  {van Lamsweerde}",
  title = 	 "{Building Formal Requirements Models for Reliable Software}",
  booktitle = 	 "{6th International Conference on Reliable Software
		  Technologies, Ada-Europe 2001}",
  volume = 	 "2043",
  series = 	 "Lecture Notes in Computer Science",
  year = 	 "2001",
  OPTorganization = "",
  publisher = "Springer--Verlag",
  address = 	 "Leuven, Belgium",
  month = 	 "May 14-18",
  OPTpages = 	 "",
  OPTnote = 	 ""}

@InProceedings{axel01b,
  author = 	 "Axel  {van Lamsweerde}",
  title = 	 "{Goal-Oriented Requirements Engineering: A Guided Tour}",
  booktitle = 	 "{RE'01 - 5th IEEE International Symposium on
		  Requirements Engineering}",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "2001",
  organization = "IEEE",
  publisher = "IEEE CS Press",
  address = 	 "Toronto, Canada",
  month = 	 "August",
  pages = 	 "249--263",
  OPTnote = 	 ""}

@InProceedings{axel02a,
  author = 	 "Emmanuel Letier and Axel  {van Lamsweerde}",
  title = 	 "{Agent-Based Tactics for Goal-Oriented Requirements
		  Elaboration}", 
  booktitle = 	 "{Proceedings ICSE'2002 - 24th International
		  Conference on Software 
		  Engineering}",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "2002",
  organization = "IEEE",
  publisher = "IEEE CS Press",
  address = 	 "Orlando, Florida, USA",
  month = 	 "May",
  OPTpages = 	 "",
  OPTnote = 	 ""}

@InProceedings{axel02b,
  author = 	 "Emmanuel Letier and Axel  {van Lamsweerde}",
  title = 	 "{Deriving Operational Software Specifications from
		  System Goals}", 
  booktitle = 	 "{Proceedings FSE'10 - 10th ACM S1GSOFT Symp. on the
		  Foundations of Software Engineering}",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "2002",
  organization = "ACM",
  publisher = "ACM",
  address = 	 "Charleston, NC, USA",
  month = 	 "November",
  OPTpages = 	 "",
  OPTnote = 	 ""}

@InProceedings{axel03,
  author = 	 "R. De Landtsheer and Emmanuel Letier and Axel  {van
		  Lamsweerde}",  
  title = 	 "{Deriving Tabular Event-Based Specifications from
		  Goal-Oriented 
		  Requirements Models}",
  booktitle = 	 "{RE'03, 11th IEEE Joint International Requirements
		  Engineering Conference}",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  year = 	 "2003",
  organization = "IEEE",
  publisher = "IEEE CS Press",
  address = 	 "Monterey, California, USA",
  month = 	 "September",
  pages = 	 "200--210",
  OPTnote = 	 ""}

  
		  

@Proceedings{ICRE94,
  title = 	 "{International Conference on Requirements
                   Engineering: ICRE'94}",
  year = 	 "1994",
  publisher = "IEEE Computer Society Press",
  OPTorganization = "IEEE Computer Society",
  address = 	 "Los Alamitos, California",
  OPTmonth = 	 "",
  OPTnote = 	 "",
  OPTannote = 	 ""
}



@Proceedings{ICRE97,
  title = 	 "{International Conference on Requirements
                   Engineering: ICRE'97}",
  year = 	 "1997",
  publisher = "IEEE CS Press",
  organization = "IEEE Computer Society",
  address = 	 "Los Alamitos, California",
  OPTmonth = 	 "",
  OPTnote = 	 "",
  OPTannote = 	 ""
}



@Proceedings{ICRE99,
  title = 	 "{International Conference on Requirements
                   Engineering: ICRE'99}",
  year = 	 "1999",
  publisher = "IEEE CS Press",
  organization = "IEEE Computer Society",
  address = 	 "Los Alamitos, California",
  OPTmonth = 	 "",
  note = 	 "Limerick, Ireland",
  OPTannote = 	 ""
}


@Book{LiL77,
  author = 	 "Jens Allwod and Lars--Gunnar 
                  Andersson and {\"O}sten Dahl",
  title = 	 "{Logic in Linguistics}",
  publisher = 	 "Cambridge University Press",
  year = 	 "1977",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  series = 	 "Cambridge Textbooks in Linguistics",
  OPTaddress = 	 "",
  OPTedition = 	 "",
  OPTmonth = 	 "",
  OPTnote = 	 "",
  OPTannote = 	 ""
}


@Book{PSRose95,
  author = "Peter S. Rose",
  title = "{Commercial Bank Management}",
  publisher = "{Irwin, Times Mirror Higher Education Group, }",
  edition = "3rd",
  year = "{1995}",
  note = "{}"}



@article{req:heitmeyer96,
AUTHOR       = "C.L. Heitmeyer and R.D. Jeffords and B.G. Labaw",
TITLE        = "{Automated Consistency Checking of Requirements
		  Specifications}", 
JOURNAL      =  "TOSEM: ACM Transactions on Software Engineering and
		  Methodology", 
VOLUME       = "5",
NUMBER       = "3",
PAGES        = "231--261",
YEAR         = "July, 1996",
NOTE         = "\dbabstract{This article describes a formal analysis
		  technique, called consistency checking, for
		  automatic detection of errors, such as type errors,
		  nondeterminism, missing cases, and circular
		  definitions, in requirements specifications. The
		  technique is designed to analyze requirements
		  specifications expressed in the SCR (Software Cost
		  Reduction) tabular notation. As background, the SCR
		  approach to specifying requirements is reviewed. To
		  provide a formal semantics for the SCR notation and
		  a foundation for consistency checking, a formal
		  requirements model is introduced; the model
		  represents a software system as a finite-state
		  automaton, which produces externally visible outputs
		  in response to changes in monitored environmental
		  quantities. Results of two experiments are presented
		  which evaluated the utility and scalability of our
		  technique for consistency checking in a real-world
		  avionics application. The role of consistency
		  checking during the requirements phase of software
		  development is discussed.}  \dbkey{D.2.1 [Software
		  Engineering]: Requirements/ Specifica-tions; D.2.2
		  [Software Engineering]: Tools and Techniques; D.2.4
		  [Software Engineering]: Program Verification; D.2.7
		  [Software Engineering]: Distribution and
		  Maintenance– docu-mentation; F.3.1 [Logics and
		  Meanings of Programs]: Specifying and Verifying and
		  Reasoning about Programs– mechanical verification;
		  specification techniques; K.6.3 [Manage-ment of
		  Computing and Information]: Software Management–
		  software development General Terms: Documentation,
		  Languages, Verification Additional Key Words and
		  Phrases: Application-independent properties,
		  consistency checking, formal requirements modeling,
		  Software Cost Reduction (SCR) methodology, tabular
		  notations}"} 


@techreport{req:hess90,
AUTHOR       = "J.A. Hess et al.",
TITLE        = "{Feature-oriented domain analysis (FODA) feasibility study}",
INSTITUTION  = "Carnegie Mellon University. SEI Software Engineering
		  Institute, DoD", 
NUMBER = "CMU-SEI-90-TR-21",
ADDRESS      = "Pittsburgh, Penn., USA",
PAGES = "148 pages",
TYPE         = "Technical Report",
MONTH        = "",
YEAR         = "1990",
NOTE         = ""}


@proceedings{req:thayer:97,
EDITOR       = "R. Thayer et al.",
TITLE        = "{Software Requirements Engineering}",
EDITION = "2nd",
ORGANIZATION = "IEEE Computer Society Press, Los Alamitos, California,
		  USA",
PAGES = "483",
YEAR         = "",
NOTE         = ""}


@book{Dietrich96,
AUTHOR       = "J. Kimball Dietrich",
TITLE        = "{Financial Services and Institutions
                 --- Value Creation in Theory and Practice}",
PUBLISHER    =  "Prentice Hall", 
ADDRESS      =  "Upper Saddle River, New Jersey 07458, USA",
YEAR         =  "1996",
NOTES        =  "xiv + 797 pages; US\,\$\,64,00; ISBN 0-02-329545-7"}

@TechReport{Naur,
  author = 	 "Peter Naur",
  title = 	 "{Datalogi som Videnskab (Datalogy as Science)}",
  institution =  "DIKU: Department of Computer Science, Copenhagen
		  University", 
  year = 	 "1995",
  type = 	 "{Discussion Report}", 
  OPTnumber = 	 "",
  address = 	 "Universitetsparken 1, DK--2100 Copenhagen {\O},
		  Denmark", 
  OPTmonth = 	 "",
  note = 	 "In Danish",
  OPTannote = 	 ""
}

 
@Article{leveson,
  author = 	 "Nancy G. Leveson and M.P.E. Heimdahl and
		  H. Hildreth, H and J.D. Reese",
  title = 	 "{Requirements Specification for Process-Control Systems}",
  journal = 	 "{IEEE Transactions on Software Engineering}",
  year = 	 "1994",
  volume = 	 "20",
  number = 	 "9",
  pages = 	 "684-707",
  month = 	 "September",
  note = 	 "\dbabstract{The paper describes an approach to writing
		  requirements specifications for process-control 
              systems, a specification language that supports this
		  approach, and an example application of the 
              approach and the language on an industrial aircraft
		  collision avoidance system (TCAS II). The 
              example specification demonstrates: the practicality of
		  writing a formal requirements specification 
              for a complex, process-control system; and the
		  feasibility of building a formal model of a system 
              using a specification language that is readable and
		  reviewable by application experts who are not 
              computer scientists or mathematicians. Some lessons
		  learned in the process of this work, which 
              are applicable both to forward and reverse engineering,
		  are also presented} \dbkey{aerospace computing;
		  aircraft instrumentation; formal specification;
		  position control; process 
              computer control; process control; specification languages}", 
  OPTannote = 	 "" 
}





@Article{TysonWolfe96,
  author = 	 "K.P. Tyson and S.C.  Wolfe",
  title = 	 "{Object-orientation and the financial services domain}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  journal = 	 "Object World UK '96",
  year = 	 "1996",
  volume = 	 "",
  number = 	 "",
  pages = 	 "105-110",
  month = 	 "",
  note = 	 "\dbabstract{The financial services industry has been
		  second only to the military in its adoption of new 
              technology in pursuit of competitive
		  advantage. Object-orientated software in general and
		  the 
              Object Management Group's CORBA specification in
		  particular is the technology du jour. We 
              discuss the issues that arise and lessons to be learned
		  from the application of the object-oriented 
              paradigm in our domain. The financial services domain
		  presents unique challenges to software 
              developers. Our experience leads us to believe that
		  there are no silver bullets. As such we tend to 
              view new solutions with a jaundiced eye, usually in
		  direct proportion to the volume of the solution's 
              marketing effort. Technology fashion statements will not
		  suffice. We feel that precise behavior 
              specifications, rigorous software engineering and
		  architectures, driven down from the business 
              requirements, are what are needed to satisfy the demands
		  of the financial domain} \dbkey{financial data
		  processing; object-oriented methods; object-oriented
		  programming}",  
  OPTannote = 	 ""
} 

@Article{req6,
  author = 	 "P. Darke and G. Shanks",
  title = 	 "{Stakeholder viewpoints in requirements definition:
		  a framework for understanding viewpoint 
              development approaches}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  journal = 	 "Requirements Engineering",
  year = 	 "1996",
  volume = 	 "1",
  number = 	 "2",
  pages = 	 "88--105",
  month = 	 "",
  note = 	 "\dbabstract{Requirements definition is a critical
		  activity within information systems development. It
		  involves 
              many stakeholder groups: managers, various end-users and
		  different systems development 
              professionals. Each group is likely to have its own
		  "viewpoint" representing a particular 
              perspective or set of perceptions of the problem
		  domain. To ensure as far as possible that the 
              system to be implemented meets the needs and
		  expectations of all involved stakeholders, it is 
              necessary to understand their various viewpoints and
		  manage any inconsistencies and conflicts. 
              Viewpoint development during requirements definition is
		  the process of identifying, understanding 
              and representing different viewpoints. This paper
		  proposes a conceptual framework for 
              understanding and investigating viewpoint development
		  approaches. Results of the use of the 
              framework for a comparison of viewpoint development
		  approaches are discussed and some 
              important issues and directions for future research are
		  identified} \dbkey{formal specification; human
		  factors; information systems; software development
		  management; 
              systems analysis}", 
  OPTannote = 	 ""
} 

@Article{req8,
  author = 	 "S. Yamamoto and H. Tadaumi and M. Ueno",
  title = 	 "{DREM: domain-based requirements engineering methodology}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  journal = 	 "NTT R \& D",
  year = 	 "1996",
  volume = 	 "45",
  number = 	 "8",
  pages = 	 "711-718",
  month = 	 "",
  note = 	 "\BREAK In Japanese. \dbabstract{Requirements Engineering for information
		  systems needs methods for developing software 
               specifications as well as methods for analysing
		  environments that include software and 
               architectures. Also interview methods are necessary for
		  good communications among customers, 
               analysts, and developers. In this paper, these
		  requirements for the next-generation requirements 
               engineering are extracted based on requirements
		  analysis experiments. Domain-based 
               Requirements Engineering Methodology, DREM, is proposed
		  as a solution} \dbkey{formal specification; information systems}", 
  OPTannote = 	 ""
} 



@InProceedings{req1,
  author = 	 "J.J.P. Tsai  and  T. Weigert and  H.C. Jang",
  title = 	 "{A hybrid knowledge representation as a basis of
		  requirement specification and reasoning}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  editor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "70-76",
  booktitle = "2nd International IEEE Conference on Tools for
		  Artificial Intelligence (Cat. 
              No.90CH2915-7)",
  year = 	 "1990",
  OPTorganization = "",
  publisher = "IEEE Comput. Soc. Press",
  OPTaddress = 	 "",
  OPTmonth = 	 "",
  note = 	 "\dbabstract{A hybrid knowledge representation
		  technique is presented which is used as a basis of a
		  requirement specification language FRORL,
		  (frame-and-rule oriented requirements specification 
              language). To easily represent the structure and
		  behavior of a software system, the syntax of 
              FRORL is based on the concepts of frames and production
		  rules. The semantic interpretation of the 
              FRORL language is defined using Horn-clause logic
		  augmented with the concept of multiple 
              inheritance. The completeness and soundness of the
		  hybrid knowledge representation technique 
              are proved. Based on the full machinery of Horn-clause
		  logic, the FRORL specification modeling 
              the world can be checked against the known constraints
		  of a given domain, and the known facts 
              pertaining to the software system} \dbkey{formal logic;
		  knowledge representation; object-oriented
		  programming; specification languages}", 
  OPTannote = 	 ""
}

@InProceedings{req2,
  author = 	 "A. Finkelstein",
  title = 	 "{Tracing back from requirements}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  editor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "",
  booktitle = "IEE Colloquium on 'Tools and Techniques for Maintaining
		  Traceability During Design' (Digest 
                No.180)",
  year = 	 "1991",
  OPTorganization = "",
  publisher = "IEE",
  address = 	 "London, UK",
  OPTmonth = 	 "",
  note = 	 "\dbabstract{The problem of achieving traceability
		  from a design, and its associated documentation,
		  back to a 
                requirements specification has been the subject of a
		  considerable amount of discussion. A much 
                less frequently discussed and, according to the
		  author, much more interesting problem, is that of 
                tracing back from the requirements specification into
		  the domain which gave rise to those 
                requirements. The author compares and contrasts these
		  two problems} \dbkey{software engineering}", 
  OPTannote = 	 "" 
}


@Article{req10,
  author = 	 "P. Loucopoulos and E. Kavakli",
  title = 	 "{Enterprise modelling and the teleological approach
		  to requirements engineering}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  journal = 	 "International Journal of Intelligent \& Cooperative Information Systems",
  year = 	 "1995",
  volume = 	 "4",
  number = 	 "1",
  pages = 	 " 45-79",
  month = 	 "March",
  note = 	 "\dbabstract{A critical factor in successful
		  requirements analysis appears to be the
		  understanding not only of 
              what the system under consideration should do, but also
		  why. To capture the purpose of an 
              information system, one needs a mechanism to describe
		  the behaviour of the organization in which 
              the system will operate. This approach suggests further
		  understanding and modelling of the 
              organizational goals and the way that these goals become
		  operationalised. In software systems 
              development we often make the distinction between the
		  enterprise world and the system world. 
              The former describes the domain about which the proposed
		  software system is to provide some 
              service, while the second is concerned with
		  specifications on what the system does and include 
              descriptions of the systems requirements, conceptual
		  designs and implementations. This paper 
              describes an approach which involves the explicit
		  modelling of organizational objectives, social 
              roles and operations and the synthesis of these
		  different perspectives towards a set of information 
              systems requirements} \dbkey{business data processing;
		  corporate modelling; formal specification;
		  information systems}", 
  OPTannote = 	 ""
}

@Proceedings{req9,
  title = 	 "{Proceedings of the Second International Conference
		  on Requirements Engineering;C olorado Springs, CO, USA}", 
  year = 	 "1996",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  publisher = "IEEE Comput. Soc. Press",
  organization = "IEEE",
  address = 	 "Los Alamitos, CA, USA",
  OPTmonth = 	 "",
  note = 	 "",
  OPTannote = 	 "\dbabstract{The following topics were dealt with:
		  experiences in elicitation; collaboration in
		  requirements 
                analysis; adapting and applying analysis methods;
		  traceability; validation and testing; 
                prioritization; considering user goals and tasks;
		  requirements processes; agreement among 
                multiple stakeholders; impact of enterprise and domain
		  requirements; natural language 
                specifications; and assessing object-orientated
		  analysis in specific domains} \dbkey{formal
		  specification; formal verification; systems
		  analysis}"  
}

@InProceedings{req7,
  author = 	 "M. Kirikova and J.A. Bubenko Jr.",
  title = 	 "{Software requirements acquisition through enterprise modelling}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "20--27",
  booktitle = "SEKE '94. The 6th International Conference on Software
		  Engineering and Knowledge Engineering", 
  year = 	 "1994",
  OPTorganization = "",
  publisher = "Knowledge Syst. Inst",
  address = 	 "Skokie, IL, USA",
  OPTmonth = 	 "",
  note = 	 "\dbabstract{Enterprise modelling technology
		  prescribes systematic use and computer aided
		  documentation of 
              knowledge about enterprises, their objectives,
		  activities, concepts, and actors. The basis of this 
              technology is the enterprise model, assumed to be
		  developed by users and requirements engineers 
              during the requirements acquisition process. The
		  enterprise model consists of several submodels, 
              that have user-oriented meta-knowledge structures for
		  communication with human sources of 
              information. The enterprise model maintains
		  relationships between information system 
              requirements and other relevant, sometimes intentional,
		  knowledge, acquired about the application 
              domain. The main objective of this technology is to
		  obtain a better alignment between the business 
              activities and the supporting information system. The
		  technology presented is also applicable in the 
              area of business process re-engineering} 
\dbkey{business data processing; corporate modelling; formal
		  specification; information systems; systems 
              analysis; systems re-engineering}",
  OPTannote = 	 ""
}


@InProceedings{req11,
  author = 	 "E. Haywood and P. Dart",
  title = 	 "{Analysis of software system requirements models}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "131--138",
  booktitle = "Australian Software Engineering Conference",
  year = 	 "1996",
  OPTorganization = "",
  publisher = "IEEE Comput. Soc. Press",
  OPTaddress = 	 "",
  OPTmonth = 	 "",
  note = 	 "\dbabstract{This paper presents an analysis of
		  models used for software system requirements. A
		  range of 
              models have been chosen to demonstrate the diversity of
		  notation, application and intention and 
              they have been considered separately from the methods
		  used for their creation. A set of criteria is 
              established as a basis for comparison of the chosen
		  models. The criteria are intended to cover 
              aspects of a requirements model which allows for
		  assessment of its suitability for a particular 
              application. Various classes of models have been
		  distinguished and a comparative overview of 
              those classes is given. The paper provides information
		  for a reader who is looking for a suitable 
              model for a particular domain. Information is presented
		  that will be of use to researchers and 
              practitioners who are interested in the provision of
		  tool support for requirements engineering. It 
              also serves as an introduction to the research area of
		  software system requirements models} \dbkey{formal
		  specification; hypermedia}", 
  OPTannote = 	 ""
}


@InProceedings{rail1,
  author = 	 "A. Bechina and J. Hermle and M.  Siormanolakis",
  title = 	 "{Using Prolog for a railway control system}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "19-30",
  booktitle = "Fourth International Conference on the Practical
		  Application of Prolog", 
  year = 	 "1996",
  OPTorganization = "",
  publisher = "Practical Application Co",
  address = 	 "Blackpool, UK",
  OPTmonth = 	 "",
  note = 	 "\dbabstract{During the last years there has been a
		  rapidly growing interest in the transportation and
		  logistics 
              domain for systems based on artificial intelligence
		  techniques. This paper proposes a practical 
              approach to an actual planning problem of a railway
		  interlocking. A railway interlocking is defined 
              as a system that is used to guarantee safe train
		  movements. Often railway interlockings are 
              systems of relays controlled by computer equipment
		  and/or human operators. In order to adapt to a 
              dynamic environment without creating dangerous
		  situations, a formalism for describing safety 
              requirements and interlocking behaviour is needed. This
		  study intends to show why a logic 
              programming language is a strong candidate for handling
		  such a formalism. This work exploits the 
              advantage of using external procedures written in other
		  languages which is supplied by many 
              software manufacturers of Prolog systems. The openness
		  of Prolog makes it a powerful language to 
              describe the complex environment of a railway system} 
           \dbkey{formal specification; logic programming; planning;
		  PROLOG; rail traffic; safety; traffic control; 
              transport control}",
  OPTannote = 	 ""
}

@InProceedings{req12,
  author = 	 "G. Kosters and H.--W.   Six and J.  Voss",
  title = 	 "{Combined analysis of user interface and domain
		  requirements}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "199-207",
  booktitle = "Second International Conference on Requirements Engineering (Cat.
              No.96TB100037); Colorado Springs, CO, USA",
  year = 	 "1996",
  OPTorganization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "",
  OPTmonth = 	 "",
  note = 	 "\dbabstract{ requirements analysis method called
		  FLUID is proposed which in contrast to conventional 
              methods explicitly captures the requirements of direct
		  manipulation user interfaces. The main 
              concepts addressing the user interface requirements
		  comprise a task model and a UIA model. The 
              latter reveals the essential structure of the user
		  interface and defines the basic dialog behavior, the
              presentation of domain model components on the screen,
		  and links to the domain model. User 
              interface requirements are described on a level of
		  abstraction similar to that of conventional 
              requirements, e.g. details of screen layout and dialog
		  behavior are deferred to later development 
              stages. The result of the entire requirements analysis-a
		  combination of domain model and UIA 
              model-serves as a basis for the further development
		  process. The method also provides for (semi) 
              automatic generation of user interface prototypes at
		  intermediate stages of the analysis} \dbkey{formal
		  specification; user centred design; user
		  interfaces}",  
  OPTannote = 	 ""
}

@InProceedings{req13,
  author = 	 "J.A. Goguen and LuQi",
  title = 	 "{Formal methods and social context in software development}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  editor = 	 "P.D. Mosses and M. Nielsen and M.I. Schwartzbach",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "62-81",
  booktitle = "TAPSOFT '95: Theory and Practice of Software
		  Development. 6th International Joint Conference 
              CAA/FASE",
  year = 	 "1995",
  OPTorganization = "",
  OPTpublisher = "",
  address = 	 "Aarhus, Denmark",
  OPTmonth = 	 "May",
  note = 	 "\dbabstract{Formal methods have not been accepted to
		  the extent for which many computer scientists
		  hoped. 
              This paper explores some reasons for that fact, and
		  proposes some ways to make progress. One 
              major problem has been that formal methods have not
		  taken sufficient account of the social context 
              of computer systems. For example, social context causes
		  a continuous evolution of requirements for  
              large complex systems. This implies that designs,
		  specifications and code must also evolve with 
              requirements, and that traceability is important. We
		  discuss a traceability technique called 
              hyper-requirements. To better understand social context,
		  we discuss ethnomethodology, a branch 
              of sociology, and situated abstract data types, which
		  help bridge the gap between the technical and 
              the social. These attempt to provide a scientific basis
		  for requirements capture. Some case studies 
              are briefly described. We distinguish between small,
		  large and huge grain formal methods, arguing 
              that small grain methods do not scale up. This motivates
		  our discussions of software composition 
              and a new paradigm of "Domain Specific Formal
		  Methods"} \dbkey{abstract data types; formal
		  specification; human factors; social aspects of
		  automation; software 
              engineering}",
  OPTannote = 	 ""
}



@Article{req14,
  author = 	 "M. Moulding and L.Smith",
  title = 	 "{Combining formal specification and CORE: an experimental investigation}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  journal = 	 "Software Engineering Journal",
  year = 	 "1995",
  volume = 	 "10",
  number = 	 "2",
  pages = 	 "31-42",
  month = 	 "March",
  note = 	 "\dbabstract{CORE is an established requirements
		  modelling method which employs diagrams and natural 
              language supporting text to express the requirements of
		  a system. The paper reports on a project 
              that has investigated the use of formal specification
		  techniques to strengthen CORE. It focuses on 
              the use of the Vienna development method (VDM) with CORE
		  and outlines an experimental 
              investigation of a proposed CORE/VDM approach within the
		  air traffic control domain. In addition, 
              the role of communicating sequential processes (CSP)
		  with CORE is discussed. The paper 
              concludes that VDM complements CORE by improving the
		  semantic definition of the resultant 
              requirements model and also suggests that CSP may be
		  used to complement VDM in order to 
              portray the dynamic and compositional aspects of a CORE
		  model} \dbkey{air traffic control; communicating
		  sequential processes; formal specification; systems
		  analysis; 
              Vienna Development Method}",
  OPTannote = 	 ""
}



@InProceedings{req-a,
  author = 	 "A. Cucchiarelli and M. Panti and S. Valenti",
  title = 	 "{Supporting user-analyst interaction in functional
		  requirements elicitation}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "114-23",
  booktitle = "First Asia-Pacific Software Engineering Conference; Tokyo, Japan",
  year = 	 "1994",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{A critical phase in the task of software
		  engineering is represented by the elicitation of 
               requirements from the users. The paper presents a
		  cognitive approach to the elicitation of 
               functional requirements of software systems founded on
		  the modelling of the application domain. 
               The framework outlined is grounded on an incremental
		  process aimed at building a description of 
               the real world, as perceived by the user and expressed
		  in an informal way, in terms of physical 
               objects and activities on them. The domain model is
		  developed by applying the analyst 
               stereotypical knowledge to the real world as described
		  by the user, and requires the identification 
               of knowledge chunks that may consent the process of
		  specification reuse in different application 
               domains} \dbkey{formal specification; human factors;
		  systems analysis; user centred design}",  
  OPTannote = 	 ""
}

@Article{Berry95,
  author = 	 "D. M. Berry",
  title = 	 "{The importance of ignorance in requirements engineering}",
  journal = 	 "{Journal of Systems and Software}",
  year = 	 "1995",
  volume = 	 "28",
  number = 	 "2",
  pages = 	 "179-184",
  month = 	 "February",
  note = 	 "\dbabstract{This paper examines a number of
		  successful requirements engineering efforts carried
		  out by 
                   the author and determines that a critical element
		  in the success of these efforts was the 
                   author's ignorance of the client's domain} 
                \dbkey{ormal specification; program verification;
		  systems analysis}",  
  OPTannote = 	 "" 
}
@InProceedings{req-b,
  author = 	 "B. Nuseibeh and J.  Kramer and A. Finkelstein",
  title = 	 "{Expressing the relationships between multiple views
		  in requirements specification}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "187-96",
  booktitle = "15th International Conference on Software Engineering
		  (Cat. No.93CH3270-6)", 
  year = 	 "1993",
  organization = "",
  publisher = "EEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{The authors generalize and formalize the
		  definition of a ViewPoint to facilitate its
		  manipulation for 
              composite system development. A ViewPoint is defined to
		  be a loosely-coupled, locally managed  
              object encapsulating representation knowledge,
		  development process knowledge and partial 
              specification knowledge about a system and its
		  domain. In attempting to integrate multiple 
              requirements specification ViewPoints, overlaps must be
		  identified and expressed, complementary 
              participants made to interact and cooperate, and
		  contradictions resolved. The notion of 
              inter-ViewPoint communication is addressed as a vehicle
		  for ViewPoint integration. The 
              communication model presented straddles both the method
		  construction stage during which 
              inter-ViewPoint relationships are expressed, and the
		  method application stage during which these 
              relationships are enacted} \dbkey{configuration
		  management; formal specification; knowledge
		  representation; object-oriented 
              programming}", 
  OPTannote = 	 ""
}

@Article{req-c,
  author = 	 "T.L. McCluskey and J.M.   Porteous and Y.   Naik and
		  C.N. Taylor and S.  Jones", 
  title = 	 "{A requirements capture method and its use in an air
		  traffic control application}", 
  journal = 	 "{Software - Practice and Experience}",
  year = 	 "1995",
  volume = 	 "25",
  number = 	 "1",
  pages = 	 "47-71",
  month = 	 "January",
  note = 	 "\dbabstract{This paper describes our experience in
		  capturing, using a formal specification language, a
		  model of 
               the knowledge-intensive domain of oceanic air traffic
		  control. This model is intended to form part of 
               the requirements specification for a decision support
		  system for air traffic controllers. We give an 
               overview of the methods we used in analysing the scope
		  of the domain, choosing an appropriate 
               formalism, developing a domain model, and validating
		  the model in various ways. Central to the 
               method was the development of a formal requirements
		  engineering environment which provided 
               automated tools for model validation and
		  maintenance} \dbkey{aerospace computing; air
		  traffic control; decision support systems; formal
		  specification; knowledge 
               representation; safety-critical software}",    
OPTannote = 	 "" 
}

@InProceedings{dom-d,
  author = 	 "A.G. Sutcliffe and N.A.M.  Maiden",
  title = 	 "{Domain modeling for reuse}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "169-177",
  booktitle = " Third International Conference on Software Reuse:
		  Advances in Software 
               Reusability (Cat. No.94TH06940); Rio de Janeiro, Brazil",
  year = 	 "1994",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{The paper presents a theory for reuse of
		  domain knowledge during requirements
		  engineering. The 
               theory includes a set of formal and reusable domain
		  abstractions, a computational analogical 
               reasoning mechanism for their retrieval and tool
		  support to enable both effective requirements 
               modeling and critiquing and guided fact capture prior
		  to retrieval. It was developed as part of the 
               ESPRIT 6353 'Nature' basic research action. The paper
		  argues that the theory has implications 
               for domain modeling as well as domain knowledge reuse
		  during requirements engineering} 
  \dbkey{cognitive systems; formal specification; knowledge
		  engineering; software reusability}",   
  OPTannote = 	 ""
}

@Article{req-e,
  author = 	 "B. Biebow and S. Szulman",
  title = 	 "{Acquisition and validation of software requirements}",
  journal = 	 "{Knowledge Acquisition}",
  year = 	 "1994",
  volume = 	 "6",
  number = 	 "4",
  pages = 	 "343-367",
  month = 	 "December",
  note = 	 "\dbabstract{The paper presents a knowledge-based
		  software engineering tool, DASERT (Detection of 
              Anomalies in Software Engineering Requirements Texts),
		  to acquire and validate functional 
              requirements in natural language. The user describes the
		  functional specifications through informal 
              methods, using graphics with comments in natural
		  language. During this elaboration step the 
              system validates the document by processing the comments
		  semantically to detect ambiguities or 
              inconsistencies. To do so it uses natural language
		  processing and knowledge base-engineering 
              DASERT's kernel is a KL-ONE-like semantic network, which
		  helps the semantic parsing of the 
              comments and their semantic representation. This
		  knowledge base is first initialized by the 
              acquisition of the lexical domain knowledge, then
		  progressively enriched with the domain 
              terminology given by the user and with the requirements
		  knowledge extracted from the user's 
              graphics and texts. During initialization and
		  enrichment, the network manager validates the 
              knowledge structurally. This ensures the logical
		  consistency of the base which is then checked for 
              inconsistencies and ambiguities specific to the domain
		  of software requirements. From a software 
              engineering point of view, the originality of DASERT is
		  that it provides a semantic checking of an 
              informal specification by interpreting the natural
		  language comments. From a knowledge acquisition 
              point of view, DASERT allows acquisition from texts to
		  build the kernel of a knowledge base which 
              is then used to guide the semantic parsing of texts
		  during the acquisition of the specification itself. 
              Moreover, the representation formalism provides a
		  unified view of acquisition and
		  validation} \dbkey{computational linguistics;
		  computer graphics; grammars; knowledge acquisition;
		  knowledge based 
              systems; knowledge verification; natural language
		  interfaces; software engineering; software tools}",
  OPTannote = 	 "" 
}
@InProceedings{arch1,
  author = 	 "H. Gomaa and  L. Kerschberg   and   V.  Sugumaran  and 
		  C. Bosch  and  I.  Tavakoli", 
  title = 	 "{A prototype domain modeling environment for
		  reusable software architectures}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  editor = 	 "W.B. Frakes",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "74-83",
  booktitle = " Third International Conference on Software Reuse:
		  Advances in Software Reusability 
              (Cat. No.94TH06940); Rio de Janeiro, Brazil",
  year = 	 "1994",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{This paper describes a prototype domain
		  modeling environment used to demonstrate the
		  concepts 
              of reuse of software requirements and software
		  architectures. The environment, which is 
              application-domain independent, is used to support the
		  development of domain models and to 
              generate target system specifications from them. The
		  prototype environment consists of an 
              integrated set of commercial-off-the-shelf software
		  tools and custom developed software tools. 
              The concept of reuse is prevalent at several levels of
		  the domain modeling method and prototype 
              environment. The environment is domain-independent
		  thereby supporting the specification of 
              diverse application domain models. The domain modeling
		  method specifies a family of systems 
              rather than a single system; optional features
		  characterize the variations in functional
		  requirements 
              supported by the family, and individual family members
		  are specified by the features they are to 
              support. The knowledge-based approach to target system
		  generation provides the rules for 
              generating target system specifications from the domain
		  model; target system specifications, 
              themselves, may be stored in an object repository for
		  subsequent retrieval and reuse} \dbkey{programming
		  environments; 
		  software prototyping; software reusability; software
		  tools}",  
  OPTannote = 	 ""
}

@Article{arch-Garlan-95a,
  author = 	 "G.D. Abowd and R.  Allen and D.  Garlan",
  title = 	 "{Formalizing style to understand descriptions of
		  software architecture}", 
  journal = 	 "{ACM Transactions on Software Engineering and Methodology}",
  year = 	 "1995",
  volume = 	 "4",
  number = 	 "4",
  pages = 	 "319-364",
  month = 	 "Oct",
  OPTnote = 	 "\dbabstract{The software architecture of most
		  systems is usually described informally and
		  diagrammatically by 
               means of boxes and lines. In order for these
		  descriptions to be meaningful, the diagrams are 
               understood by interpreting the boxes and lines in
		  specific, conventionalized ways. The informal, 
               imprecise nature of these interpretations has a number
		  of limitations. In this article the authors 
               consider these conventionalized interpretations as
		  architectural styles and provide a formal 
               framework for their uniform definition. In addition to
		  providing a template for precisely defining new 
               architectural styles, this framework allows for
		  analysis within and between different architectural 
               styles} \dbkey{diagrams; flowcharting; software engineering}", 
  OPTannote = 	 "" 
}
@InProceedings{req-f,
  author = 	 "M. Jarke, M et al.", 
  title = 	 "{Requirements engineering: an integrated view of
		  representation, process, and domain}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  editor = 	 "I. Sommerville and M. Paul",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "100-114",
  booktitle = "Software Engineering - ESEC '93. 4th European Software
		  Engineering Conference Proceedings;
		  Garmisch-Partenkirchen, Germany",  
  year = 	 "1993", 
  organization = "",
  publisher = "Springer-Verlag",
  address = 	 "Berlin, Germany",
  month = 	 "",
  note = 	 "\dbabstract{Reuse, system integration, and
		  interoperability create a growing need for
		  capturing, representing, 
              and using application-level information about software
		  intensive systems and their evolution. In 
              ESPRIT Basic Research Project NATURE, we are developing
		  an integrative approach to 
              requirements management based on a three-dimensional
		  framework which addresses formalism as 
              well as cognitive and social aspects. This leads to a
		  new requirements process model which 
              integrates human freedoms through allowing relatively
		  free decisions in given situations. Classes of 
              situations and decisions are defined with respect to the
		  three-dimensional framework through the 
              integration of informal and formal representations,
		  theories of domain modeling, and the explicit 
              consideration of nonfunctional requirements in
		  teamwork. Technical support is provided by a 
              conceptual modeling environment with knowledge
		  acquisition through interactive as well as reverse 
              modeling, and with similarity-based querying} 
            \dbkey{formal specification; open systems; systems analysis}", 
  OPTannote = 	 ""
}

@InProceedings{req-g,
  author = 	 "N.A.M. Maiden and A.G.  Sutcliffe",
  title = 	 "{Requirements critiquing using domain abstractions}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "184-193",
  booktitle = "First International Conference on Requirements Engineering (Cat.
              No.94TH0613-0); Colorado Springs, CO, USA",
  year = 	 "1994",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{Reusing domain abstractions representing
		  key domain features has been shown to aid
		  requirement 
              specification, however their role in requirements
		  engineering has not been investigated thoroughly. 
              This paper proposes domain abstractions to aid
		  requirements critiquing as well as specification, 
              thus maximising the payoff from retrieving domain
		  abstractions. The requirements critic is part of a 
              prototype intelligent requirements engineering toolkit
		  being developed as part of the Nature 
              project, ESPRIT basic research action 6353. The critic
		  retrieves domain abstractions to validate 
              requirement specifications for problems including
		  incompleteness, inconsistencies and ambiguities. 
              Intelligent, mixed initiative dialogue between the
		  critic and requirements engineer permits
              requirements critiquing at the right time and level of
		  abstraction} \dbkey{formal specification;
		  programming environments; research initiatives;
		  software engineering; 
              software reusability}",   
  OPTannote = 	 ""
}

@InProceedings{req-Boehm,
  author = 	 "B. Boehm and H.  In",
  title = 	 "{Identifying quality-requirement conflicts}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "218",
  booktitle = "Second International Conference on Requirements Engineering (Cat.
              No.96TB100037); Colorado Springs, CO, USA",
  year = 	 "1996",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{One of the biggest risks in software
		  requirements engineering is the risk of
		  overemphasizing one 
              quality attribute requirement (e.g., performance) at the
		  expense of others at least as important 
              (e.g., evolvability and portability). The paper
		  describes an exploratory knowledge based tool for 
              identifying potential conflicts among quality attributes
		  early in the software/ system life cycle. The 
              Quality Attribute Risk and Conflict Consultant (QARCC)
		  examines the quality attribute tradeoffs 
              involved in software architecture and process
		  strategies. It operates in the context of the USC
		  CSE 
              WinWin system, a groupware support system for
		  determining software and system requirements 
              as negotiated win conditions. We have developed and
		  experimented with an initial QARCC 1 
              prototype. We are using the results of the experiment to
		  develop an improved QARCC 2 tool. From 
              our initial experimentation, we concluded that QARCC can
		  alert users, developers, customers, and 
              other stakeholders to conflicts among their software
		  quality requirements and can help them 
              identify additional, potentially important quality
		  requirements. We also concluded that QARCC 
              needs further refinement to avoid overloading users with
		  insignificant quality conflict suggestions. 
              We are now refining the knowledge base to address more
		  detailed quality attributes in a more 
              selective fashion} \dbkey{ormal specification;
		  groupware; software quality}",  
  OPTannote = 	 ""
}

@InProceedings{Garlan-94a,
  author = 	 "R. Allen and D. Garlan",
  title = 	 "{Formalizing architectural connection}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "71-80",
  booktitle = "16th International Conference on Software Engineering
		  (Cat. No.94CH3409-0); Sorrento, Italy",
  year = 	 "1994",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  OPTnote = 	 "\dbabstract{As software systems become more complex
		  the overall system structure - or software 
              architecture - becomes a central design problem. An
		  important step towards an engineering 
              discipline of software is a formal basis for describing
		  and analyzing these designs. We present a 
              theory for one aspect of architectural description, the
		  interactions between components. The key 
              idea is to define architectural connectors as explicit
		  semantic entities. These are specified as a 
              collection of protocols that characterize each of the
		  participant roles in an interaction and how these 
              roles interact. We illustrate how this scheme can be
		  used to define a variety of common 
              architectural connectors. We provide a formal semantics
		  and show how this lends to a sound 
              deductive system in which architectural compatibility
		  can be checked in a way analogous to type 
              checking in programming languages} \dbkey{formal
		  specification; programming theory; software
		  engineering; systems analysis}",  
  OPTannote = 	 ""
}

@Article{arch-Mowbray,
  author = 	 "T. Mowbray",
  title = 	 "{The seven deadly sins of OO architecture}",
  journal = 	 "{Object Magazine; SIGS Publications}",
  year = 	 "1997",
  volume = 	 "7",
  number = 	 "1",
  pages = 	 "21, 24",
  month = 	 "March",
  note = 	 "\dbabstract{Deadly sins are mistakes in software
		  development that result in failed projects, cost
		  overruns, 
              schedule slips, and unfulfilled business needs. Deadly
		  sins are pervasive: one third of all software 
              projects are cancelled and five out of six software
		  projects are unsuccessful. Unfortunately, object 
              technology has not changed this overall prognosis. In
		  fact, each new technology wave (such as 
              client/server) tends to increase software risk and the
		  tendency to commit deadly sins. Experts such 
              as J. Stikeleather (1996), G. Booch (1996), M. Shaw and
		  D. Garlan (1996), and others agree. 
              Software architecture is perhaps the most significant
		  factor in software system success or failure. 
              There are some interesting and distinctive deadly sins
		  associated with object oriented (OO) 
              software architectures. Two of these seven deadly sins
		  of OO architecture which are unpardonable 
              are: the sin of haste, which leads to poor architecture
		  quality, and the sin of avarice, which leads to 
              excessive architecture complexity. Once these particular
		  mistakes are committed system wide, 
              they may be impossible to remediate. The other deadly
		  sins are closely related to these 
              unpardonable sins} \dbkey{object-oriented programming;
		  project management; software development management;
		  software 
              quality; software reliability}", 
  OPTannote = 	 "" 
}
@InProceedings{arch-Magee,
  author = 	 "J. Magee and J. Kramer",
  title = 	 "{Dynamic structure in software architectures}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  editor = 	 "D. Garlan",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "3-14",
  booktitle = "SIGSOFT '96. Proceedings of the Fourth ACM SIGSOFT
		  Symposium on the Foundations of 
              Software Engineering; San Francisco, CA, USA",
  year = 	 "1996",
  organization = "",
  publisher = "ACM",
  address = 	 "New York, NY, USA",
  month = 	 "",
  note = 	 "\dbabstract{Much of the recent work on architecture
		  description languages (ADLs) has concentrated on 
              specifying organisations of components and connectors
		  which are static. When the ADL 
              specification is used to drive system construction, then
		  the structure of the resulting system in 
              terms of its component instances and their
		  interconnection is fixed. This paper examines ADL 
              features which permit the description of dynamic
		  software architectures in which the organisation of 
              components and connectors may change during system
		  execution. The paper outlines examples of 
              language features which support dynamic structure. These
		  examples are taken from Darwin, a 
              language used to describe distributed system
		  structures. An operational semantics for these 
              features is presented in the $\pi$-calculus, together with
		  a discussion of their advantages and 
              limitations. The paper discusses some general approaches
		  to dynamic architecture description 
              suggested by these examples} \dbkey{distributed
		  processing; process algebra; software engineering;
		  specification languages}",  
  OPTannote = 	 ""
}

@InProceedings{arch-Garlan96a,
  author = 	 "D. Garlan",
  title = 	 "{Formal approaches to software architecture}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "64-76",
  booktitle = "Studies of Software Design. ICSE `93 Workshop. Selected Papers",
  year = 	 "1996",
  organization = "",
  publisher = "Springer-Verlag",
  address = 	 "Berlin, Germany",
  month = 	 "",
  OPTnote = 	 "\dbabstract{An important goal in software
		  engineering is to describe complex software systems
		  at an 
              architectural level of abstraction. While good software
		  engineers routinely employ architectural 
              concepts in their designs these concepts are typically
		  used idiomatically and in an ad hoc fashion. 
              What appears to, be missing is a formal basis for
		  software architecture. But what exactly does this 
              mean? We illustrate by example three approaches to
		  formalizing software architecture. The first 
              represents an industrial development effort to formalize
		  a specific class of applications. The second 
              shows how to use formalism to understand the design
		  space for a commonly used architectural 
              style. The third considers the problem of providing a
		  formal basis for the generic notion of 
              architectural interconnection} \dbkey{formal
		  specification; software engineering}",  
  OPTannote = 	 ""
}

@InProceedings{arch-Poulin96,
  author = 	 "J.S. Poulin et al.",
  title = 	 "{A reuse-based software architecture for management
		  information systems}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "M. Sitaraman",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "94-103",
  booktitle = "Fourth International Conference on Software Reuse
		  (Cat. No.96TB100015); Orlando, FL, USA",
  year = 	 "1996",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  note = 	 "\dbabstract{The paper describes a software
		  architecture for applications in the domain of
		  management 
              information systems (MIS). Using principles of software
		  reuse and the architectural concepts 
              introduced by D. Garlan and M. Shaw (1993), the paper
		  describes the software architecture in 
              terms of reusable components (of both and data) which
		  provide domain independent and domain 
              specific components for shared business functions. The
		  architecture identifies the connectors 
              between the components and gives rules that specify the
		  constraints within which to apply the 
              architecture. We describe the architecture using four
		  "views" in order to help interpret the 
              architecture for developers. We then implement the
		  architecture with a set of architectural models 
              in our CASE toolset; these models serve as reusable
		  templates from which developers can 
              instantiate their own architectural models. Designed to
		  fully comply with Open Systems 
              Environment standards and in use today on one of the US
		  Army`s largest information systems, this 
              architecture has led to unmodified component reuse
		  levels of over 20% as completion nears on the 
              first 7 of as many as 60 projected applications} 
           \dbkey{computer aided software engineering; management
		  information systems; military computing;}",  
  OPTannote = 	 ""
}

@InProceedings{arch-Allen96,
  author = 	 "R. Allen and D. Garlan",
  title = 	 "{A case study in architectural modeling: the AEGIS system}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "6-15",
  booktitle = "8th International Workshop on Software Specification
		  and Design; Schloss Velen, Germany",
  year = 	 "1996",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  OPTnote = 	 "\dbabstract{Software architecture is receiving
		  increasingly attention as a critical design level
		  for software 
               systems. However the current practice of architectural
		  description is largely informal and ad hoc, 
               with the consequence that architectural documents serve
		  as a poor communication mechanism, are 
               difficult to analyze, and may have very little
		  relationship to the implemented system. In an
		  attempt 
               to address these problems several researchers have
		  experimented with formalisms for 
               architectural specification and modelling. One such
		  formalism is the WRIGHT specification 
               language. In this paper, we show how WRIGHT can be used
		  to provide insight into an 
               architectural design by modelling a prototype
		  implementation of part of the AEGIS Weapons 
               System (AWS)} \dbkey{formal specification; military
		  computing; specification languages; weapons}",  
  OPTannote = 	 ""
}
@Article{arch-Garlan-ACMCS95,
  author = 	 "D. Garlan",
  title = 	 "{Research directions in software architecture}",
  journal = 	 "{ACM Computing Surveys}",
  year = 	 "1995",
  volume = 	 "27",
  number = 	 "2",
  pages = 	 "257-261",
  month = 	 "June",
  OPTnote = 	 "\dbabstract{Although application of good
		  architectural design is becoming increasingly
		  important to software 
              engineering, much common practice leads to architectural
		  designs that are informal, ad hoc, 
              unanalyzable, unmaintainable, and
		  handcrafted. Consequently architectural design is
		  only vaguely 
              understood by developers; architectural choices are
		  based more on default than on solid engineering 
              principles; architectural designs cannot be analyzed for
		  consistency or completeness; architectures 
              are not enforced as a system evolves; and there are
		  virtually no tools to help architectural 
              designers. Current research in software architecture
		  attempts to address all of these issues; among 
              the more active areas are: architecture description
		  languages; formal underpinnings of software 
              architecture; architectural analysis techniques;
		  architectural development methods; architecture 
              recovery and reengineering; architectural codification
		  and guidance;  tools and environments for
              architectural design; and case studies of architectural
		  design} \dbkey{software engineering; systems analysis}",   
  OPTannote = 	 "" 
}



@InBook{arch-GarlanShaw93,
  author = 	 "D. Garlan and M. Shaw",
  title = 	 "{An introduction to software architecture}",
  year = 	 "1993",
  pages = "1--39",
  booktitle = "Advances in software engineering and knowledge engineering",
  chapter = "",
  publisher = "World Scientific",
  address = 	 "Singapore",
  OPTnote = 	 "\dbabstract{As the size of software systems
		  increases, the algorithms and data structures of the
		  computation 
              no longer constitute the major design problems. When
		  systems are constructed from many 
              components, the organization of the overall system-the
		  software architecture-presents a new set 
              of design problems. This level of design has been
		  addressed in a number of ways including informal 
              diagrams and descriptive terms, module interconnection
		  languages, templates and frameworks for 
              systems that serve the needs of specific domains, and
		  formal models of component integration 
              mechanisms. We provide an introduction to the emerging
		  field of software architecture. We begin by 
              considering a number of common architectural styles upon
		  which many systems are currently based 
              and show how different styles can be combined in a
		  single design. Then we present six case 
              studies to illustrate how architectural representations
		  can improve our understanding of complex 
              software systems. Finally, we survey some of the
		  outstanding problems in the field, and consider a 
              few of the promising research directions} \dbkey{data
		  structures; software engineering; systems analysis}"}

@InProceedings{arch-Shekaran94,
  author = 	 "C. Shekaran and D. Garlan and et al.",
  title = 	 "{The role of software architecture in requirements
		  engineering}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "239-245",
  booktitle = " First International Conference on Requirements Engineering (Cat.
               No.94TH0613-0); Colorado Springs, CO, USA",
  year = 	 "1994",
  organization = "",
  publisher = "IEEE Comput. Soc. Press",
  address = 	 "Los Alamitos, CA, USA",
  month = 	 "",
  OPTnote = 	 "\dbabstract{The role of software architecture
		  (which reflects high-level implementation
		  constraints) in 
               requirements engineering is clarified by providing
		  perspectives on relevant issues, including the 
               following: is requirements engineering merely a front
		  end to the software development process that 
               is concerned only with problem definition? Is software
		  architecture an application-specific, 
               high-level design of a system (for example, ``an
		  object-oriented system with a specified object 
               hierarchy'')? What is the relationship between the
		  problem definition and the solution structure? 
               What is the relationship between the roles of
		  requirements engineer, software architect, and 
               application domain specialist?. \dbkey{formal
		  specification; professional aspects; systems
		  analysis}}",  
  OPTannote = 	 ""
}
@Article{arch-Abowd-SIGSOFT93,
  author = 	 "G. Abowd and R.  Allen and D.  Garlan",
  title = 	 "{Using style to understand descriptions of software
		  architecture}", 
  journal = 	 "{SIGSOFT Software Engineering Notes}",
  year = 	 "1993",
  volume = 	 "18",
  number = 	 "5",
  pages = 	 "9-20",
  month = 	 "December",
  OPTnote = 	 "\dbabstract{The software architecture of most
		  systems is described informally and
		  diagrammatically. In order 
              for these descriptions to be meaningful at all, figures
		  are understood by interpreting the boxes and 
              lines in specific, conventionalized ways. The
		  imprecision of these interpretations has a number of  
              limitations. In this paper we consider these
		  conventionalized interpretations as architectural
		  styles 
              and provide a formal framework for their uniform
		  definition. In addition to providing a template for 
              precisely defining new architectural styles, this
		  framework allows for the proof that the notational 
              constraints on a style are sufficient to guarantee the
		  meanings of all described systems and 
              provides a unified semantic base through which different
		  stylistic interpretations can be
		  compared} \dbkey{formal languages; formal
		  specification; specification languages}",   
  OPTannote = 	 "" 
}
@InProceedings{arch-GarlanShaw,
  author = 	 "D. Garlan and M. Shaw",
  title = 	 "{Experience with a course on architectures for
		  software systems}", 
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "23-43",
  booktitle = "Software Engineering Education. SEI Conference 1992;
		  San Diego, CA, USA", 
  year = 	 "199",
  organization = "",
  publisher = "Springer-Verlag",
  address = 	 "Berlin, Germany",
  month = 	 "",
  OPTnote = 	 "\dbabstract{As software systems grow in size and
		  complexity their design problem extends beyond 
               algorithms and data structures to issues of system
		  design. This area receives little or no 
               treatment in existing computer science
		  curricula. Although courses about specific systems
		  are 
               usually available, there is no systematic treatment of
		  the organizations used to assemble 
               components into systems. These issues-the software
		  architecture level of software design-are 
               the subject of a course that was taught first in Spring
		  1992. The paper describes the motivation for 
               the course, the content and structure of the current
		  version, and our plans for improving the next 
               version} \dbkey{computer science education;
		  educational courses; software engineering}",  
  OPTannote = 	 ""
}
@InProceedings{arch-Allen92,
  author = 	 "R. Allen and D. Garlan",
  title = 	 "{A formal approach to software architectures}",
  OPTcrossref =  "",
  OPTkey = 	 "",
  OPTeditor = 	 "",
  volume = 	 "vol.A-12",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  pages = 	 "134-141",
  booktitle = "IFIP Transactions A (Computer Science and Technology);
		  IFIP Wordl Congress; Madrid, Spain",
  year = 	 "1992",
  organization = "IFIP",
  publisher = "North Holland",
  address = 	 "Amsterdam, Netherlands",
  month = 	 "",
  OPTnote = 	 "\dbabstract{An important goal in software
		  engineering is to describe complex software systems
		  at an 
                architectural level of abstraction. While there are
		  many useful architectural paradigms (pipes, 
                blackboards, etc.) they are typically understood only
		  idiomatically and applied in an ad hoc 
                fashion. The authors show how a formal model allows
		  one to say precisely what is meant by a 
                software architecture, explore its properties, and
		  systematically describe instances of the 
                architecture} \dbkey{formal logic; formal
		  specification; software engineering}",  
  OPTannote = 	 ""
}




@techreport{bjorner-paradigm97,
AUTHOR       = "Dines Bj{\o}rner",
TITLE        = "{A Software Engineering Paradigm:
From Domains via Requirements to Software}",
INSTITUTION  = "Department of Information Technology, Techical
		  University of Denmark",
ADDRESS      = "Bldg. 345/167, DK--2800 Lyngby, Denmark; db@it.dtu.dk;
		  Fax: +45-45-88.45.30",
TYPE         = "Research Report",
MONTH        = "July",
YEAR         = "1997",
OPTNOTE         = "\dbabstract{We outline and illustrate, by examples, a
software developement 
  process. This process consists of three major components: 
  domain engineering, requirements engineering and software design. 
  They enable the important principle of {\sl
  separation of concerns.\/}
Domain engineering establishes models of the domain (the environment).
  A domain model is --- in principle --- void of any reference
  to computing and strives to describe (explain) the domain 
  \underline{{\bf as}} \underline{{\bf it}} \underline{{\bf is}}. 
  By domain we roughly understand the area of human or other activity 
  for which some software support is required.
  Domain analysis investigates the domain with a view towards establishing a
  domain theory. The aim of a domain theory is to capture laws of the domain.
In requirements engineering, requirements captur  establishes models
		  of the requirements.  
  Requirements models are derived from domain models. Requirements
  engineering also analyses requirements models, i.e.\
   requirements analysis, in order to derive further properties of the
		  requirements. 
  Thus  requirements  describes the domain as the customer
		  \underline{{\bf would}} 
  \underline{{\bf like}} \underline{{\bf to}} \underline{{\bf see}}
  \underline{{\bf it}}.  
Software design proceeds from establishing a software architecture, to
		  deriving a program organisation, and from 
  that, in further steps of refinement, constructing the
  ``executable code''.
The software architecture establishes the concepts and facilities
		  offered the user of 
the software --- i.e.\ the external interfaces, whereas the 
program organisation
establishes internal interfaces between program modules (processes,
platform components, etc.). Refinement covers the derivation from the
		  requirements model 
of the architecture, of the program organisation from the
		  architecture, and of further steps of 
concretisations into code.
All stages and steps of the software development process construct
		  informal as well 
as formal descriptions. Software development may be characterised as
		  proceeding 
in either a systematic, a rigorous or even, in parts, a formal manner
--- all depending on the extent to which the underlying formal
notation is exploited in reasoning about properties of the evolving
descriptions: validation and verification.
Software engineering is seen as the process of going between science
		  and technology. 
That is, of developing software on the basis of scientific results and
using mathematics --- as in other engineering branches --- and of
understanding (the constructed domain of) 
existing (software) technologies by subjecting them to
rigorous domain analysis} \dbkey{software engineering, formal
		  specification, domain engineering, requirements
		  engineering, refinement, software architecture,
		  program organisation}"}



@article{guarino:fo:caakr,
AUTHOR       = "Nicola Guarino",
TITLE        = "{Formal Ontology, Conceptual Analysis and
                 Knowledge Representation}",
JOURNAL      = "International Journal of Human and
                Computer Studies",
VOLUME       = "",
NUMBER       = "",
PAGES        = "",
YEAR         = "1996",
NOTE         = "Special issue on: (see title) 
             Formal Ontology, Conceptual Analysis and
                 Knowledge Representation; edited by
            N.\ Guarino and R.\ Poli"}

@inbook{enterprise:toronto,
AUTHOR       = "Anon",
TITLE        = "{XXX}",
BOOKTITLE    = "{Enterprise Integration}",
PUBLISHER    = "Chapmann \& Hall",
CHAPTER      = "10",
PAGES        = "",
YEAR         = "1995",
NOTE         = ""}

@article{clancey93,
AUTHOR       = "W.J. Clancey",
TITLE        = "{The Knowledge Level Reinterpreted: Modelling
Socio--Technical Systems}",
JOURNAL      = "International Jounral of Intellegent Systems",
VOLUME       = "8",
NUMBER       = "",
PAGES        = "33--49",
YEAR         = "1993",
NOTE         = "\dbabstract{Knowledge acquisition is a process of
		  developing qualitative models of 
		  systems in the 
              world-physical, social, technological-often for the
		  first time, not extracting facts and rules that are 
              already written down and filed away in an expert's
		  mind. Models of reasoning describe how people 
              behave-how they interactively gather evidence by looking
		  and asking questions, represent a 
              situation by saying and writing things, and plan to act
		  in some environment. But such models are 
              inherently brittle mechanisms: Human reinterpretation of
		  rules and procedures is metaphorical, 
              based on prelinguistic perceptual categorization and
		  nondeliberated sensory-motor coordination. 
              This view of people, relative to computer models, yields
		  an alternative view of what tools can be 
              and the tool design process. Knowledge engineers are
		  called to participate with social scientists 
              and workers in the codesign of the workplace and tools
		  for enhancing worker creativity and 
              response to unanticipated situations. The emphasis is on
		  augmenting human capabilities as they 
              interact with each other to construct new
		  conceptualizations-facilitating conversations, not
		  just   
              automating routine behavior. Software development in the
		  context of use maintains connection to 
              nontechnical, social factors such as ownership of ideas
		  and authority to participate. The role of 
              knowledge engineering is not merely 'capturing
		  knowledge' in a program delivered by technicians to 
              users. Rather, one seeks to develop tools that help
		  people in a community in their everyday practice 
              of creating new understandings and capabilities, new
		  forms of knowledge.} \dbkey{knowledge acquisition;
		  social aspects of automation}"} 


 